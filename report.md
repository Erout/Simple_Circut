# 期末项目 Simple_Circuit 实验报告
## 代码运行方法
详见makefile文件

## 操作方法
输入数字以进行相应的操作

- 1->创建一个门（提供的类型有：与门、或门、非门、与非门、或非门）
- 2->连接两个特定的门（需要输入两个门对应的id，第一个输入的门将会连接到第二个输入的门）
- 3->列出所创建的门的列表（包括门的id、门的类型）
- 4->设置门的输入（输入 id，选取特定的门，再输入0 1 序列表示您的输入，输入一个非0 1 数字以终止输入）
- 5->把电路打印出来（以邻接矩阵表示门的连接，并打印指定门的输出）
- 6->运行电路（需要再连接电路并添加足够的输入之后才能运行）
- 7-> 清除各个门的输入，不改变电路的连接方式，您可以重新往电路里面提供输入
- 8->清除整个电路，这意味着您可以重新开始您的电路设计
- 9->退出此程序

## 设计思路
### 封装对象
- circuitControl
使用了单例模式，控制整个电路，包括门的创建（用链表储存），门的连接方式（使用邻接矩阵记录）等，并且提供了创建、连接、设置输入、运行、打印、清除、异常检测等基本方法
- door
基类对象，private里面有name、id、input、output等属性，并且提供了各种设置以及获取这些属性的方法
- doorAnd  doorOr doorNot doorAndNot doorOrNot
这些都是派生类对象，从door继承而来，setinput 和getOutput的方法不一样（根据门的属性getoutput）

### 运算符重载
door里面有一个+=运算符的重载，表示往这个门里面增加输入:
```
door& door::operator+=(door& d){
    input_.push_back(d.output_);
    return *this;
}
```
另外有一个=号的重载，但是后来发现似乎并没有用到...

### 其他思路
- execute的方法里面使用了DFS对门进行了拓扑排序，按照排好的拓扑序来一个个获取门的输出并往下一个门里面增加输入

## 拓展点
- 设置了或非门和与非门
- 较为友善的GUI界面...
- 可以只清空输入而不清空电路来进行重新设置输入

## 改进空间
- 设置一个remove的操作，在电路连接出问题的时候就可以不用清空整个电路了，只用remove就可以
- 交互界面可以更好一点
- 打印电路的时候可以考虑更好看的打印方法，比如把电路图整个打印出来这样